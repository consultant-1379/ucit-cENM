#!/bin/bash
#*******************************************************************************
# Version 1.0
# COPYRIGHT Ericsson 2023
#
# The copyright to the computer program(s) herein is the property of
# Ericsson Inc. The programs may be used and/or copied only with written
# permission from Ericsson Inc. or in accordance with the terms and
# conditions stipulated in the agreement/contract under which the
# program(s) have been supplied.
#********************************************************************************
#
# Last revision: 23 Oct 2023
#
#set -v
#
# DO NOT EDIT This file if found on a cENM service group project.
# Master file is under: https://gerrit.ericsson.se/gitweb?p=OSS/ENM-Parent/SQ-Gate/com.ericsson.oss.containerisation/ucit-cENM.git
#
# This file is updated by run_update_credm_info script
# see: https://confluence-oss.seli.wh.rnd.internal.ericsson.com/display/ENMCOMECIM/Script+automation+for+Credential+Manager+introduction+on+cENM+service+group
#
# Script to download all CRL
#
# when run with "force" will start in foreground regardless last run
# otherwise will check if already run and fork itself in background
#
# Usage:
#
# updateCRL.sh [force|forced] [batch]
#
# force: force the run without checking last run time.
# forced: force the run without checking last run time, but stay in foreground instead of running in background.
#
#  batch:  Internal "self used" argument to respawn itself in background
#
#
# Crl are reloaded every min_update since last update.
#
min_update=1800
#
if [ -d /var/tmp ]; then
  LOG_DIR=/var/tmp
else
  LOG_DIR=/tmp
fi
#
# Number of lines to keep from a file to trim
#
MAX_LINES=10000
#
readonly script_name=$0
readonly GET_CRL=$LOG_DIR/get_crl
readonly CRL_DIR=$LOG_DIR/crl_dir
readonly CA_SERIALS=$LOG_DIR/ca_serials
readonly CA_SERIALS_NEW=$LOG_DIR/ca_serials.new
readonly RENAME_CRL=$LOG_DIR/rename_crl
readonly MY_PID=$LOG_DIR/updateCRL.pid
#
readonly release=$(grep '^# Last revision:' $script_name | sed 's/^# Last revision://')
readonly version=$(grep '^# Version' $script_name | sed 's/^# Version//')
#
OCF_RESTART="$LOG_DIR/restart_required"
#
if [ -f $OCF_RESTART ]; then
  # Return "failure"
  exit 1
fi
#
LOG=$LOG_DIR/updateCRL.log
ERR=$LOG_DIR/updateCRL.err
#
last_update=$LOG_DIR/updateCRL.last
#
> $LOG.tmp
touch $LOG
#
last_run=0
if [ -f $last_update ]; then
  last_run=$( cat $last_update );
fi
#
# If $1 is force or force will run anyways. forced means also that will run in foregraound
#
if [ "$1" == "force" ]; then
  last_run=0
  shift # remove "force" from arguments
  echo "Forcing run"
fi
#
if [ "$1" == "forced" ]; then
  last_run=1
  shift # remove "forced" from arguments
  echo "Forcing run"
fi
#
# Logger utility function (stdout+file)
#
my_logger() {
  d=$(date)
  if ! grep -q "$*" $LOG.tmp ; then
    echo "$d $*" | tee -a $LOG $LOG.tmp
  fi
}
#
# Log only to file
#
silent_logger() {
  d=$(date)
  if ! grep -q "$*" $LOG.tmp ; then
    echo "$d $*" | tee -a $LOG >> $LOG.tmp
  fi
}
#
# keep last MAX_LINES from a file
#
prune_log() {
  tail -n $MAX_LINES $1 > $1.short
  mv $1.short $1
}
#
#
#
# Bash doesn't allow to set variables from child back to parent.
# Workaround is to return as list of keys:value
# Utility to get a return value from a list of lines
# Arguments:
# get_ret the_key <list_of <key:value> \n separated>
# the_key: is searched among the passed list and all matches are returned.
# lines are in the format:
# key:values
#
get_ret() {
  key=$1
  lines="$2"
  grep "$1:" <<< "$lines" | sed "s/^$1://"
}
#
# Get list of all certificate information
# Output Format is: <list of entry>
# Where one entry has the following format:
# a="$a",t="$t",tj="$tj",tp="$tp",p="$p",crtca="$crta",crd="$crd"
#
# $a     The truststore storealias
# $t     The storelocation type (jks for jkstruststore / pem for base64truststore)
# $tf    The storelocation
# $tj    The storelocation for jkstruststore
# $tp    The storelocation for base64truststore
# $p     The storepassword
# $crtca The storealias (used as prefix on crl file name)
# $crd   The crl storefolder
#
# Note $tf is copied into $tp for base64truststore or inro $tj for jkstruststore
#
get_cert_list() {
  xml="$1"
  echo $((
  echo 'p="";tf="";tp="";tj="";a="";t="";crta="";crd="";'
  sed -n "\_<truststore>_,\_</truststore>_p" $xml | sed 's/\r//' | expand | sed -e 's, *,,' \
        -e 's,",,g' \
        -e 's,`,,g' \
        -e 's,<truststore>,,' \
        -e 's,<base64truststore>,t="pem",' \
        -e 's,</base64truststore>,tp="$tf";tf="",' \
        -e 's,<jkstruststore>,t="jks",' \
        -e 's,</jkstruststore>,tj="$tf";tf="",' \
        -e 's,<storefolder>\([^<]*\)</storefolder>,<storelocation>\1/trustca_all.pem</storelocation>,' \
        -e 's,//trustca_all,/trustca_all,' \
        -e '\_<storepassword>\s*$_{N;\_</storepassword>_s/\n//}' \
        -e 's;<storepassword>\(.*\)</storepassword>;p="\1";' \
        -e 's;<storealias>\(.*\)</storealias>;a="\1";' \
        -e 's;<storelocation>\(.*\)</storelocation>;tf="\1";' \
        -e 's,</truststore>,,' \
        -e '/^$/d'
#
#
  sed -n "\_<crlstore>_,\_</crlstore>_p" $xml | sed 's/\r//' | expand | sed -e 's, *,,' \
        -e 's,",,g' \
        -e 's,`,,g' \
        -e 's;<storefolder>\(.*\)</storefolder>;crd="\1";' \
        -e 's,<base64crlstore>,,' \
        -e 's,</base64crlstore>,,' \
        -e '\_<storepassword>\s*$_{N;\_</storepassword>_s/\n//}' \
        -e 's;<storealias>\(.*\)</storealias>;crta="\1";' \
        -e 's;<storepassword>\(.*\)</storepassword>;;' \
        -e 's,<crlstore>,,' \
        -e 's;</crlstore>;echo a="$a",t="$t",tj="$tj",tp="$tp",p="$p",crtca="$crta",crd="$crd",;'
  ) | sh)
}
#
# Parse an xml file and check for crlUpdate checkcause
#
#  <oncheckresult>
#    <actionlist>
#      <checkcause>certificateUpdate</checkcause>
#      <checkcause>trustUpdate</checkcause>
#      <checkcause>crlUpdate</checkcause>
#      <action>VMRestart</action>
#    </actionlist>
#  </oncheckresult>
#
get_crl_restart() {
#
  xml="$1"
  crl_restart="false"
  check_actions=$(sed -n "\_<oncheckresult>_,\_</oncheckresult>_p" $xml | sed 's/\r//' | expand | sed -e 's, *,,' | egrep "<checkcause>crlUpdate</checkcause>|<action>VMRestart</action>" )
  if echo "$check_actions" | grep -q "crlUpdate" ; then
    if echo "$check_actions" | grep -q "VMRestart" ; then
      crl_restart="true"
    fi
  fi
  echo $crl_restart
}
#
# return a shell parseable, variable definition line to be used by eval
# to define some variables
#
get_vars() {
  var_list="$1"
  #
  # For each line change the string to become a "sh" variabla assignmnet
  # E.g.:
  #  a=123,b=hello world,
  # becomes:
  #  a="123";b="hello world"
  #
  def_var=$( echo "$var_list" | sed -e 's/=/="/g' -e 's/,/";/g')
  #
  # Set all the service variables defined on the line that will be evaluated by the caller
  #
  echo $def_var
}
#
# Extract info from truststore file.
#
get_ca_info_list_from_trust() {
  if echo "$tp" | grep -q -i "pem$" || [ "$t" == "pem" ] ; then
#
#   Example of selected fields from PEM file:
#
#        Serial Number: 414984539922958210 (0x5c2523d89630782)
#        Subject: CN=NE_OAM_CA, C=SE, O=ERICSSON, OU=BUCI_DUAC_NAM
#                  URI:http://131.160.152.19:8092/pki-cdps?ca_name=ENM_PKI_Root_CA&ca_cert_serialnumber=27c60193c6f4418a
#                  URI:http://[2001:1b70:6207:23:0:3905:5244:2a]:8092/pki-cdps?ca_name=ENM_PKI_Root_CA&ca_cert_serialnumber=27c60193c6f4418a
#        Serial Number: 2865979947077616010 (0x27c60193c6f4418a)
#        Subject: CN=ENM_PKI_Root_CA, C=SE, O=ERICSSON, OU=BUCI_DUAC_NAM
#        Serial Number:            c3:2b:c0:58:c9:ea:e9:2c
#        Subject: C=IN, ST=TS, L=HYD, O=TCS, OU=ERICSSON, CN=NSSCA
#
    ca_info_list=$(
      openssl crl2pkcs7 -nocrl -certfile $tp | openssl pkcs7 -print_certs -noout -text | sed '/Serial Number: *$/N;s/\n//' | egrep 'Serial Number:|Subject:|URI.*/pki-cdps.ca_name=|X509v3 Key Usage' | (
	sed -e 's/.*Serial Number:.*(0x\(.*\)/sn="\1";/'  \
	    -e 's/.*Serial Number: *\([0-9a-f]{2}:\)/sn="\1";/'  \
	    -e 's/URI:\(.*\).ca_name=.*/uri="\1"; subj=$(echo "$ssubj"|sed "s, ,,g") ; echo "$subj;$sn;$uri"/' \
	    -e 's/Subject: *\(.*\)/ssubj="\1";/' \
	    -e 's/Serial Number: *\([0-9a-fA-F:]*\)$/sn="\1"/' \
	    -e 's/.*X509v3 Key Usage.*/subj=$(echo "$ssubj"|sed "s, ,,g") ; echo "$subj;$sn;$uri"/'
	) | sed 's/)"/"/' | sh
      )
  else
    if echo "$tj" | grep -q -i "jks$" || [ "$t" == "jks" ] ; then
#
#   Example of selected fields from JKS file:
#
#  Owner: OU=BUCI_DUAC_NAM, O=ERICSSON, C=SE, CN=ENM_PKI_Root_CA
#  Serial number: 27c60193c6f4418a
#  Owner: OU=BUCI_DUAC_NAM, O=ERICSSON, C=SE, CN=NE_OAM_CA
#  Serial number: 5c2523d89630782
#       [URIName: http://131.160.152.19:8092/pki-cdps?ca_name=ENM_PKI_Root_CA&ca_cert_serialnumber=27c60193c6f4418a]
#       [URIName: http://[2001:1b70:6207:23:0:3905:5244:2a]:8092/pki-cdps?ca_name=ENM_PKI_Root_CA&ca_cert_serialnumber=27c60193c6f4418a]
#  Owner: CN=NSSCA, OU=ERICSSON, O=TCS, L=HYD, ST=TS, C=IN
#  Serial number: c32bc058c9eae92c
#
      if [ -z "$p" ]; then
        pwd_opt=""
      else
        pwd_opt="-storepass"
      fi
      ca_info_list=$(
	keytool -list -v -keystore $tj -storetype jks $pwd_opt $p < /dev/null | sed '/Serial number: *$/N;s/\n//' | egrep 'Serial number:|Owner:|URIName.*/pki-cdps.ca_name=|SubjectKeyIdentifier'  | (
	  sed -e 's/.*Serial number:.*(0x\(.*\)/sn="\1";/' \
	      -e 's/.*Serial number: *\([0-9a-f]{2}:\)/sn="\1";/' \
	      -e 's/.*URIName: \(.*\).ca_name=.*/uri="\1"; subj=$(echo "$ssubj"|sed "s, ,,g") ; echo "$subj;$sn;$uri";/' \
	      -e 's/Owner: *\(.*\)/ssubj="\1";/' \
	      -e 's/Serial number: *\([0-9a-fA-F:]*\)$/sn="\1"/' \
	      -e 's/SubjectKeyIdentifier.*/subj=$(echo "$ssubj"|sed "s, ,,g") ; echo "$subj;$sn;$uri";/'
	  ) | sed 's/)$//' | sh
	)
    fi
  fi
  #
  # Return a list of lines in the format:
  # <CA subject>;<CA serial number>;<CDPS URI>
  #
  echo $ca_info_list
}
#
# Get list of CA and cdps uri from the $ca_info_list variable
#
obtain_uri_and_ca_list() {
  ca_list=""
  u_uri=""
  u_uri6=""
  for l in $(echo "$ca_info_list" | sort -u)
  do
    if ! echo "$l" | grep -Fq '//[' ; then
      u_uri=$(echo $l | sed -e 's/.*;http/http/' -e 's/,*//' | grep http | grep "/pki-cdps")
    else
      if [ -z "$uri6" ]; then
	u_uri6=$(echo $l | sed -e 's/.*;http/http/' -e 's/,*//' | grep http | grep "/pki-cdps")
      fi
    fi
    ca_name=$(echo $l | sed -e 's/;http.*//' -e 's/;$//')
    ca_list=$( (for y in $ca_list $ca_name; do echo $y ; done )| sort -u)
  done
  #
  silent_logger "ca_list:""$ca_list"
  #
  uri="http://pkiraserv:8092/pki-cdps"
  if ! curl "$uri/ca_serials?ca_name=not_existent_ca" >> $ERR 2>&1 ; then
    uri=""
    uri6="http://pkiraserv:8092/pki-cdps"
    if ! curl -6 "$uri/ca_serials?ca_name=not_existent_ca" >>$ERR 2>&1 ; then
      silent_logger "Falling back to the URI found inside the certs"
      uri="$u_uri"
      uri6="$u_uri6"
    fi
  fi
  #
  # Output return value as list of key:value
  #
  echo "uri:$uri"
  echo "uri6:$uri6"
  for ca in $ca_list
  do
    echo "ca:$ca"
  done
}
#
# Get ca serials and md5 from a Ca or ca issuers for external CA
# The function will search for both internal and external CA matching the name.
# For Internal CA only the CN=<ca_name> is used.
# For External CA the full DN is used.
# Potential "conflict" will lead to have an extra CRL (if any) if External CN name matches an internal one.
# This is "tollerated" because is very unlikely that a valid certificare has a serial number that matches
# one inside the extenal CRL with same CN.
# Client SHOULD also check if the serial number that has signed the CRL matches the one of the CA that has signed the certificate
# whose serial number is searched for.
#
get_ca_serials_or_issuers() {
  extIssuers=""
  serials=""
  ica=$(echo "$ca" | sed 's/.*CN=//' | sed -e 's/,.*//' -e 's/;.*//')
  eca=$(echo "$ca" | sed -e 's/ //g' -e 's/;.*//')
  if [ -z "$uri" ]; then
    serials=$(curl -g -6 "$uri6/ca_serials/?ca_name=$ica" 2>> $ERR | egrep -iv "Couldn't|ot found|ExtCACRLRemoteServiceBean" | sed 's/\[//g' | sed 's/\]//g' | sed 's/,/ /g' | sed 's/"//g' ; echo)
    extIssuers=$(curl -g -6 "$uri6/offline_external_ca_serials/?ca_name='$eca'" 2>> $ERR | egrep -iv "Couldn't|ot found|ExtCACRLRemoteServiceBean" | sed 's/\[//g' | sed 's/\]//g' | sed 's/ /_-_/g' | sed 's/","/ /g' | sed 's/"//g' | sort -u ; echo)
  else
    serials=$(curl -g "$uri/ca_serials/?ca_name=$ica" 2>> $ERR | egrep -iv "Couldn't|ot found|ExtCACRLRemoteServiceBean" | sed 's/\[//g' | sed 's/\]//g' | sed 's/,/ /g' | sed 's/"//g' ; echo)
    extIssuers=$(curl -g "$uri/offline_external_ca_serials/?ca_name='$eca'" 2>> $ERR | egrep -iv "Couldn't|ot found|ExtCACRLRemoteServiceBean" | sed 's/\[//g' | sed 's/\]//g' | sed 's/ /_-_/g' | sed 's/","/ /g' | sed 's/"//g' | sort -u ; echo)
  fi
  #
  # Prepare return list of key:value pairs
  #
  for ex in $extIssuers
  do
    echo "ex:$ex"
  done
  for ser in $serials
  do
    echo "ser:$ser"
  done
  echo "ica:$ica"
  echo "eca:$eca"
}
#
# Process line for ENM internal CA
# $si contains a serial_number;md5  pair
#
process_enm_ca() {
  #
  # Assumes that the CA is an internal CA
  # if is not, the return error is skipped.
  # This may cause an external ca can be considered as internal if the same CN is used (is a limitation of internal database)
  #
  sn=$(echo "$si" | sed 's/;.*//')
  echo "$ica;$si" >> $CA_SERIALS_NEW
  crl_file="${crd}/${crtca}_${ica}_${sn}.crl"
  if ! grep -q "$ica;$si" $CA_SERIALS || [ ! -f ${crl_file} ] ; then
    my_logger "Updating internal CA: $ica;$sn"
    if [ -f ${crl_file} ]; then
      # File exists, this mean that the checksum is different. Touch the restart file if is required by on the xml file.
      if [ "$crl_restart" == "true" ]; then
	my_logger "Restart request"
        touch $OCF_RESTART
      fi
    fi
    # write the download crl command on get_crl file.
    if [ -z "$uri" ]; then
      if [ ! -z "$uri6" ]; then
	echo "curl -g -6 '$uri6?ca_name=$ica&ca_cert_serialnumber=$sn' 2>> $ERR | openssl crl -inform der -out ${crl_file}" >> $GET_CRL
      else
	my_logger "No URI to fetch CRl for CA:$ica"
      fi
    else
      echo "curl -g '$uri?ca_name=$ica&ca_cert_serialnumber=$sn' 2>> $ERR | openssl crl -inform der -out ${crl_file}" >> $GET_CRL
    fi
  else
    my_logger "Found: $ica;$si will keep old crl"
  fi
  # At each run only the "discovered" crl files will remain on the crl dir.
  echo "${crl_file}" >> $RENAME_CRL
}
#
# Process line for external CA
#
process_external_ca() {
  #
  # Assumes that the CA is an external CA
  # if is not, the return error is skipped.
  # This may cause an internal ca considered as external if the same CN is used (is a limitation of internal database)
  #
  extca=$(echo "$si" | sed 's/;.*//')
  sn=$(echo "$si" | sed "s/$extca;//" | sed 's/;.*//')
  echo "$si" >> $CA_SERIALS_NEW
  crl_file="${crd}/${crtca}_${extca}_${sn}.crl"
  if ! grep -q "$si" $CA_SERIALS || [ ! -f ${crl_file} ] ; then
    my_logger "Updating external CA: $si"
    if [ -f ${crl_file} ]; then
      if [ "$crl_restart" == "true" ]; then
	my_logger "Restart request"
	touch $OCF_RESTART
      fi
    fi
    if [ -z "$uri" ]; then
      if [ ! -z "$uri6" ]; then
	echo "curl -g -6 '$uri6/offline_external_crl?ca_name=$extca&crl_issuer=$sn' 2>> $ERR | openssl crl -inform der -out ${crl_file}" >> $GET_CRL
      else
	my_logger "No URI to fetch CRl for CA:$extca"
      fi
    else
      echo "curl -g '$uri/offline_external_crl?ca_name=$extca&crl_issuer=$sn' 2>> $ERR | openssl crl -inform der -out ${crl_file}" >> $GET_CRL
    fi
  else
    my_logger "Found: $si will keep old crl"
  fi
  echo "${crl_file}" >> $RENAME_CRL
}
#
# All the created files are processed to remove duplicates
#
process_script_files() {
  sort -u $CA_SERIALS_NEW > $CA_SERIALS
  #
  sort -u $CRL_DIR > $CRL_DIR.tmp
  sort -u $GET_CRL > $GET_CRL.tmp
  sort -u $RENAME_CRL > $RENAME_CRL.tmp
  #
  mv $CRL_DIR.tmp $CRL_DIR
  mv $GET_CRL.tmp $GET_CRL
  mv $RENAME_CRL.tmp $RENAME_CRL
}
#
# Process all the created script files
#
execute_script_files() {
  if [ -s $GET_CRL ]; then

    for dname in $(cat $CRL_DIR)
    do
      if [ ! -d $dname ]; then
        my_logger "Creating dir: $dname"
        mkdir $dname 2>> $ERR
      fi
    done

    my_logger "Renaming CRL to keep if any"
    for f in $(cat $RENAME_CRL)
    do
      if [ -f $f ]; then
	my_logger "Renaming $f to $f.sav"
	mv $f $f.sav
      fi
    done

    for dname in $(cat $CRL_DIR)
    do
      my_logger "Removing no more used crl from dir: $dname"
      rm $dname/*.crl 2>> $ERR
    done

    my_logger "Restoring CRL to keep"
    for f in $(cat $RENAME_CRL)
    do
      if [ -f ${f}.sav ]; then
	mv $f.sav $f
      fi
    done

    my_logger "Downloading CRL files to CRL dir"
    cat $GET_CRL | tee -a $LOG
    . $GET_CRL |& tee -a $LOG

    my_logger "Downloaded files"
  fi
}
#
#
init_files() {
  >$CRL_DIR
  >$GET_CRL
  > $RENAME_CRL
  touch $CA_SERIALS
  > $CA_SERIALS_NEW
}
#
now=$(date +%s)
delta=$(( now - last_run ))
#
sed -i "/Last run ver:$version rel:$release/d" $LOG
my_logger "Last run ver:$version rel:$release"
#
# Check if it's too early to run "main" code.
#
if [  "$delta" -le $min_update ] ; then
  exit 0
fi
#
echo $now > $last_update
#
if [ "$1" == "monitor" ]; then
  delay=1.$(echo $$ | sed 's/.*\(.\)$/\1/')
  if  ! -f $MY_PID ; then
    echo $$ > $MY_PID
  fi
  sleep $delay
  if [ $(cat $MY_PID) != $$ ] ; then
    exit 0
  fi
  shift # Remove "monitor" argument if any
fi
#
# When "self run" using batch the script will run in foreground.
#
if [ "$1" != "batch" ]; then
  # Run batch mode myself
  # last_run==0 means force mode background
  # last_run==1 means forced mode foreground
  if [ "$last_run" == "1" ]; then
    # Run in foreground.
    echo "Interactive run"
    $script_name forced batch $*
  else
    # Run in background.
    $script_name force batch $* &
  fi
  # Exit after self-calling
  exit 0
else
  # remove first argument ( "batch" )
  shift
fi
#
my_logger "Updating CRLs ($$)"
#
#
###############################################
#
# MAIN program
#
init_files
#
# Get all xml files
xmls=/ericsson/credm/data/xmlfiles/*.xml
#
# Loop acroaa al xml files
#
for x in $xmls
do
#
  cert_list=$(get_cert_list $x)
  crl_restart=$(get_crl_restart $x)
#
# Loop through all certificate info list
#
#
  for c in $cert_list
  do
    #
    eval $(get_vars "$c")
    #
    echo "${crd}" >> $CRL_DIR
    #
    ca_info_list=$(get_ca_info_list_from_trust)
    #
    ret=$(obtain_uri_and_ca_list)
    uri=$(get_ret "uri" "$ret")
    uri6=$(get_ret "uri6" "$ret")
    ca_list=$(get_ret "ca" "$ret")
    #
    for ca in $(echo $ca_list)
    do
      ret=$(get_ca_serials_or_issuers)
      serials=$(get_ret "ser" "$ret")
      ica=$(get_ret "ica" "$ret")
      eca=$(get_ret "eca" "$ret")
      extIssuers=$(get_ret "ex" "$ret")
      my_logger "Internal Ca serials: $serials"
      #
      for si in $serials
      do
	process_enm_ca
      done
      #
      msg=$(echo "External Ca issuers: $extIssuers" | sed 's/_-_/ /g')
      my_logger "$msg"
      #
      extIssuerSorted=""
      for si in $extIssuers
      do
	process_external_ca
      done
      #
    done
  done
done
#
# remove duplicate from script files
#
process_script_files
#
# execute all generated script files in order.
#
execute_script_files
#
# Prune log files
#
prune_log $LOG
prune_log $ERR
#
# Return "OK"
#
exit 0
#
